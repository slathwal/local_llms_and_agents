{
  "hash": "0fc3447b951f3c3c9b92bd693eff7004",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Graph basics in LangGraph\"\nauthor: \"Shefali Lathwal\"\ndate: \"2025-04-25\"\ndate-modified: last-modified\neditor: visual\ntoc: true\nformat: html\njupyter: python_langchain\nexecute:\n  freeze: auto\n---\n\n\n# The Simplest Graph\n\n-   Nodes (Agent and Tools)\n-   Edges (Simple, conditional)\n\n## Define State\n\nThe first thing you do when you define a graph is to define a `State`. State is the object that we pass between the nodes and edges of our graph. The state schema serves as the input schema for all Nodes and Edges in the graph.\n\n::: {#419371bb .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import TypedDict\n\n# Define that state should be a dictionary with a single key - graph_state with values of type string\nclass State(TypedDict):\n    graph_state: str\n```\n:::\n\n\n::: callout-note\nTypedDict does not do checking of input during run. We need to do checking separately. If we want to do dynamic checking while running a cell, we need to use `BaseModel` from pydantic.\n:::\n\n## Define nodes\n\n-   Nodes are just python functions\n\n-   The first positional argument is the state.\n\n-   Each node operates on the state.\n\n-   By default, each node also overrides the previous state value.\n\n::: {#b05b7a83 .cell execution_count=2}\n``` {.python .cell-code}\ndef node_1(state):\n    print(\"---Node 1---\")\n    return {\"graph_state\": state[\"graph_state\"]+\"I am\"}\n\ndef node_2(state):\n    print(\"---Node 2---\")\n    return {\"graph_state\": state[\"graph_state\"]+\" happy!\"}\n\ndef node_3(state):\n    print(\"---Node 3---\")\n    return {\"graph_state\": state[\"graph_state\"]+\" sad!\"}\n\n```\n:::\n\n\n## Define Edges\n\nEdges connect the nodes.\n\n-   Normal edges are used if you want to go from one node to the next.\n\n-   Conditional edges are used when you want to optionally route between nodes.\n\n-   Conditional edge is implemented as a function that returns the next node to visit based on some logic.\n\n::: {#2c9295d8 .cell execution_count=3}\n``` {.python .cell-code}\nimport random\nfrom typing import Literal # Literal is used for restricting a value to a fixed set of constants\n\ndef decide_mood(state) -> Literal[\"node_2\", \"node_3\"]:\n\n    # Often, we will use state to decide on the next node to visit\n    # We are not doing anything with the current state right now.\n    user_input = state[\"graph_state\"]\n\n    # Here, we are just doing a 50/50 split\n    if random.random()<0.5:\n        return \"node_2\"\n    \n    return \"node_3\"\n```\n:::\n\n\n## Construct the graph\n\n-   Now we will build a graph from our components - nodes and edges.\n\n-   The `StateGraph` class is the one we will use.\n\n-   First we initialize a `StateGraph` with the `State` class we had defined.\n\n-   Then, we will add our nodes and edges.\n\n-   We use the START node, a special node that sends user input to the graph, to indicate where to start our graph.\n\n-   We use END node, which is a special node, to indicate end of the graph.\n\n-   We will compile our graph to check the structure of our graph.\n\n-   We will then visualize the graph.\n\n::: {#9ef33a37 .cell execution_count=4}\n``` {.python .cell-code}\nfrom IPython.display import Image, display\nfrom langgraph.graph import StateGraph, START, END\n\n# Build graph\nbuilder = StateGraph(State)\nbuilder.add_node(\"node_1\", node_1)\nbuilder.add_node(\"node_2\", node_2)\nbuilder.add_node(\"node_3\", node_3)\n\nbuilder.add_edge(START, \"node_1\")\nbuilder.add_conditional_edges(\"node_1\", decide_mood)\nbuilder.add_edge(\"node_2\", END)\nbuilder.add_edge(\"node_3\", END)\n\n# Compile the graph\ngraph = builder.compile()\n\n# View the graph\ndisplay(Image(graph.get_graph().draw_mermaid_png()))\n```\n\n::: {.cell-output .cell-output-display}\n![](05_graph_basics_langgraph_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n# Implement/Invoke a graph\n\n-   The compiled graph implements the `runnable` protocol.\n\n-   This provides a standard way to execute LangChain components.\n\n-   `invoke` is one of the standard methods in this interface.\n\n-   The input to our SimpleGraph is a dictionary with one key \"graph_state\", which sets the initial value of the graph_state.\n\n-   When invoke is called, the graph starts execution from the `START` node.\n\n-   Each node function receives the current state and overrides it.\n\n-   The execution continues until it reaches the `END` node.\n\n::: {#1865c1f4 .cell execution_count=5}\n``` {.python .cell-code}\ngraph.invoke({\"graph_state\": \"Hi, this is Lance.\"})\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n---Node 1---\n---Node 3---\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n{'graph_state': 'Hi, this is Lance.I am sad!'}\n```\n:::\n:::\n\n\n-   `invoke` runs the entire graph synchronously.\n\n-   it waits for each step to complete before moving to the next.\n\n-   It returns the final state of the graph after all nodes have executed.\n\n-   In the case of SimpleGraph, it would return the state after `node_3` has completed.\n\n",
    "supporting": [
      "05_graph_basics_langgraph_files"
    ],
    "filters": [],
    "includes": {}
  }
}